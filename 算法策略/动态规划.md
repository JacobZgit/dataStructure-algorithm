过程：（以 leetcode746. 使用最小花费爬楼梯 为例）
1.确定dp数组以及下标的含义:
  使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。
  dp[i]的定义：到达下标为i的台阶所费最小值。
2.确定递推公式:
  要么从 i-1 上到 i，要么从 i-2 上到 i，取最小值
  dp[i] = Math.min(dp[i - 1] + cost[i-1], dp[i - 2] + cost[i-2]);
3.dp数组如何初始化：
  根据dp数组的定义，dp数组初始化其实是比较难的，因为不可能初始化为第i台阶所花费的最少体力。
  那么看一下递归公式，dp[i]由dp[i-1]，dp[i-2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]dp[1]推出。
  所以初始化代码为：
          dp[0] = 0;
          dp[1] = 0;
4.确定遍历顺序：
  最后一步，递归公式有了，初始化有了，如何遍历呢？
  本题的遍历顺序其实比较简单，简单到很多同学都忽略了思考这一步直接就把代码写出来了。
  因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。
  但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来。
  例如：01背包，都知道两个for循环，一个for遍历物品嵌套一个for遍历背包容量，那么为什么不是一个for遍历背包容量嵌套一个for遍历物品呢？ 以及在使用一维dp数组的时候遍历背包容量为什么要倒叙呢？
  这些都是遍历顺序息息相关。当然背包问题后续「代码随想录」都会重点讲解的！

<!-- leetcode746. 使用最小花费爬楼梯
    class Solution {
    //动态规划
    public int minCostClimbingStairs(int[] cost) {
        int size = cost.length;
        int[] minCost = new int[size];
        //minCost[i]：到达下标为i的台阶所费最小值
        minCost[0] = 0;
        minCost[1] = 0;
        for (int i = 2; i < size; i++) {
            minCost[i] = Math.min(minCost[i - 1] + cost[i-1], minCost[i - 2] + cost[i - 2]);
        }
        //最后要到达顶楼，要么从台阶[size-1]上（步数无所谓），要么从台阶[size-2]上跨两步上
        return Math.min(minCost[size - 1] + cost[size - 1], minCost[size - 2] + cost[size - 2]);
    }
} -->